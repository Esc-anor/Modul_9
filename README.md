module_9_1
    Цель: научиться обращаться к функциям, как к объекту и передавать их в другие функции для вызова.
    
    Задача "Вызов разом":
    Напишите функцию apply_all_func(int_list, *functions), которая принимает параметры:
    int_list - список из чисел (int, float)
    *functions - неограниченное кол-во функций (которые применимы к спискам, состоящим из чисел)
    Эта функция должна:
    Вызвать каждую функцию к переданному списку int_list
    Возвращать словарь, где ключом будет название вызванной функции, а значением - её результат работы со списком int_list.
    Пункты задачи:
    В функции apply_all_func создайте пустой словарь results.
    Переберите все функции из *functions.
    При переборе функций записывайте в словарь results результат работы этой функции под ключом её названия.
    Верните словарь results.
    Запустите функцию apply_all_func, передав в неё список из чисел и набор других функций.
    Пример результата выполнения программы:
    В примере используются следующие функции:
    min - принимает список, возвращает минимальное значение из него.
    max - принимает список, возвращает максимальное значение из него.
    len - принимает список, возвращает кол-во элементов в нём.
    sum - принимает список, возвращает сумму его элементов.
    sorted - принимает список, возвращает новый отсортированный список на основе переданного.
    Пример работы кода:
    print(apply_all_func([6, 20, 15, 9], max, min))
    print(apply_all_func([6, 20, 15, 9], len, sum, sorted))
    Вывод на консоль:
    {'max': 20, 'min': 6}
    {'len': 4, 'sum': 50, 'sorted': [6, 9, 15, 20]}
    Примечания:
    Для того, чтобы взять название функции можно обратиться к атрибуту __name__
    При попытке передачи, например, списка из строк, некоторые функции могут работать некорректно или вовсе не работать. Используйте списки чисел.

module_9_2
    Цель: закрепить знания о списочных и словарных сборках, решив несколько небольших задач.
    
    Задача:
    Даны несколько списков, состоящих из строк
    first_strings = ['Elon', 'Musk', 'Programmer', 'Monitors', 'Variable']
    second_strings = ['Task', 'Git', 'Comprehension', 'Java', 'Computer', 'Assembler']
    В переменную first_result запишите список созданный при помощи сборки состоящий из длин строк списка first_strings, при условии, что длина строк не менее 5 символов.
    В переменную second_result запишите список созданный при помощи сборки состоящий из пар слов(кортежей) одинаковой длины. Каждое слово из списка first_strings должно сравниваться с каждым из second_strings. (два цикла)
    В переменную third_result запишите словарь созданный при помощи сборки, где парой ключ-значение будет строка-длина строки. Значения строк будут перебираться из объединённых вместе списков first_strings и second_strings. Условие записи пары в словарь - чётная длина строки.
    
    Пример результата выполнения программы:
    Пример выполнения кода:
    print(first_result)
    print(second_result)
    print(third_result)
    Вывод на консоль:
    [10, 8, 8]
    [('Elon', 'Task'), ('Elon', 'Java'), ('Musk', 'Task'), ('Musk', 'Java'), ('Monitors', 'Computer'), ('Variable', 'Computer')]
    {'Elon': 4, 'Musk': 4, 'Programmer': 10, 'Monitors': 8, 'Variable': 8, 'Task': 4, 'Java': 4, 'Computer': 8}
    
    Примечания:
    Помните, когда вы используете 2 цикла for внутри сборки, первый цикл - внешний, второй - внутренний.

module_9_3
    Цель: понять механизм создания генераторных сборок и использования встроенных функций-генераторов.
    
    Задача:
    Дано 2 списка:
    first = ['Strings', 'Student', 'Computers']
    second = ['Строка', 'Урбан', 'Компьютер']
    Необходимо создать 2 генераторных сборки:
    В переменную first_result запишите генераторную сборку, которая высчитывает разницу длин строк из списков first и second, если их длины не равны. Для перебора строк попарно из двух списков используйте функцию zip.
    В переменную second_result запишите генераторную сборку, которая содержит результаты сравнения длин строк в одинаковых позициях из списков first и second. Составьте эту сборку НЕ используя функцию zip. Используйте функции range и len.
    
    Пример результата выполнения программы:
    Пример выполнения кода:
    print(list(first_result))
    print(list(second_result))
    Вывод в консоль:
    [1, 2]
    [False, False, True]
    Примечания:
    Это небольшая практика, поэтому важность выполнения каждого условия обязательна.

module_9_4
    Цель: освоить на практике замыкание, объекты-функторы и lambda-функции.
    
    Задача "Функциональное разнообразие":
    Lambda-функция:
    Даны 2 строки:
    first = 'Мама мыла раму'
    second = 'Рамена мало было'
    Необходимо составить lambda-функцию для следующего выражения - list(map(?, first, second)).
    Здесь ? - место написания lambda-функции.
    
    Результатом должен быть список совпадения букв в той же позиции:
    [False, True, True, False, False, False, False, False, True, False, False, False, False, False]
    Где True - совпало, False - не совпало.
    
    Замыкание:
    Напишите функцию get_advanced_writer(file_name), принимающую название файла для записи.
    Внутри этой функции, напишите ещё одну - write_everything(*data_set), где *data_set - параметр принимающий неограниченное количество данных любого типа.
    Логика write_everything заключается в добавлении в файл file_name всех данных из data_set в том же виде.
    Функция get_advanced_writer возвращает функцию write_everything.
    
    Данный код:
    write = get_advanced_writer('example.txt')
    write('Это строчка', ['А', 'это', 'уже', 'число', 5, 'в', 'списке'])
    Запишет данные в файл в таком виде:
    
    Метод __call__:
    Создайте класс MysticBall, объекты которого обладают атрибутом words хранящий коллекцию строк.
    В этом классе также определите метод __call__ который будет случайным образом выбирать слово из words и возвращать его. Для случайного выбора с одинаковой вероятностью для каждого данного в коллекции можете использовать функцию choice из модуля random.
    
    Ваш код (количество слов для случайного выбора может быть другое):
    from random import choice
    # Ваш класс здесь
    first_ball = MysticBall('Да', 'Нет', 'Наверное')
    print(first_ball())
    print(first_ball())
    print(first_ball())
    Примерный результат (может отличаться из-за случайности выбора):
    Да
    Да
    Наверное
    
    Примечания:
    Все задания пишутся в одном модуле.
    Передаваемые данные в функции и объекты можете использовать свои, главное, чтобы ваш код полноценно демонстрировал логику написанного.

module_9_5
    Цель: освоить механизмы работы итераторов и описания методов __next__ и __iter__. Закрепить навык создания и выбрасывания исключений.
    
    Задача "Range - это просто":
    Создайте пользовательский класс исключения StepValueError, который наследуется от ValueError.
    Наследования достаточно, класс оставьте пустым при помощи оператора pass.
    
    Создайте класс Iterator, который обладает следующими свойствами:
    Атрибуты объекта:
    start - целое число, с которого начинается итерация.
    stop - целое число, на котором заканчивается итерация.
    step - шаг, с которым совершается итерация.
    pointer - указывает на текущее число в итерации (изначально start)
    Методы:
    __init__(self, start, stop, step=1) - принимающий значения старта и конца итерации, а также шага. В этом методе в первую очередь проверяется step на равенство 0. Если равно, то выбрасывается исключение StepValueError('шаг не может быть равен 0')
    __iter__ - метод, сбрасывающий значение pointer на start и возвращающий сам объект итератора.
    __next__ - метод, увеличивающий атрибут pointer на step. В зависимости от знака атрибута step итерация завершится либо когда pointer станет больше stop, либо меньше stop. Учтите это при описании метода.
    
    Пункты задачи:
    Создайте класс исключения StepValueError.
    Создайте класс Iterator и опишите его атрибуты и методы.
    Создайте несколько объектов класса Iterator и совершите итерации с ними при помощи цикла for.
    
    Пример результата выполнения программы:
    Пример выполняемого кода:
    try:
    iter1 = Iterator(100, 200, 0)
    for i in iter1:
    print(i, end=' ')
    except StepValueError:
    print('Шаг указан неверно')
    
    iter2 = Iterator(-5, 1)
    iter3 = Iterator(6, 15, 2)
    iter4 = Iterator(5, 1, -1)
    iter5 = Iterator(10, 1)
    
    
    for i in iter2:
    print(i, end=' ')
    print()
    for i in iter3:
    print(i, end=' ')
    print()
    for i in iter4:
    print(i, end=' ')
    print()
    for i in iter5:
    print(i, end=' ')
    print()
    
    Вывод на консоль:
    Шаг указан неверно
    -5 -4 -3 -2 -1 0 1
    6 8 10 12 14
    5 4 3 2 1
    
    Примечания:
    Особое внимание уделите методу __next__ и условиям в нём.

module_9_6
    Цель: более глубоко понять особенности работы с функциями генераторами и оператором yield в Python.
    
    Задача:
    Напишите функцию-генератор all_variants(text), которая принимает строку text и возвращает объект-генератор, при каждой итерации которого будет возвращаться подпоследовательности переданной строки.
    
    Пункты задачи:
    Напишите функцию-генератор all_variants(text).
    Опишите логику работы внутри функции all_variants.
    Вызовите функцию all_variants и выполните итерации.
    Пример результата выполнения программы:
    Пример работы функции:
    a = all_variants("abc")
    for i in a:
    print(i)
    Вывод на консоль:
    a
    b
    c
    ab
    bc
    abc
    
    Примечания:
    Для функции генератора используйте оператор yield.

module_9_7
    Цель задания:
    Освоить механизмы создания декораторов Python.
    Практически применить знания, создав функцию декоратор и обернув ею другую функцию.
    
    Задание:
    Напишите 2 функции:
    Функция, которая складывает 3 числа (sum_three)
    Функция декоратор (is_prime), которая распечатывает "Простое", если результат 1ой функции будет простым числом и "Составное" в противном случае.
    Пример:
    result = sum_three(2, 3, 6)
    print(result)
    
    Результат консоли:
    Простое
    11
    
    Примечания:
    Не забудьте написать внутреннюю функцию wrapper в is_prime
    Функция is_prime должна возвращать wrapper
    @is_prime - декоратор для функции sum_three


